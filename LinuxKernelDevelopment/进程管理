进程就是处于执行期的程序，但是进程并不仅仅局限于一段可执行的代码，进程还包含其他资源，比如打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间，一个或多个执行线程，存放全局变量的数据段。

两个或两个以上并存的进程可以共享许多注入打开的文件，地址空间之类的资源。

执行线程，是进程中活动的对象；每个线程拥有一个独立的程序计数器，进程栈和一组进程寄存器，内核调度的对象是线程，而不是进程。

Linux对线程和进程不作区分，对Linux而言，线程只不过是一种特殊的进程。

现在操作系统中，进程提供两种虚拟制度：虚拟处理器和虚拟内存。
虚拟处理器让进程感觉自己在独享处理器。
虚拟内存让进程再分配和管理内存时觉得自己拥有整个系统的内存资源。
线程之间可以共享整个虚拟内存，但每个线程都拥有各自的虚拟处理器。

进程在创建它的时刻开始存活，在Linux系统中，通常是调用fork()的结果，该系统调用通过复制一个现有现有进程来创建一个全新的进程。
调用fork()的进程叫父进程，新产生的进程成为子进程。
fork()系统调用从内核返回两次：一次回到父进程，一次回到新产生的子进程。

程序通过exit()系统调用退出执行，这个函数会终结进程并将其占用的资源释放掉。
父进程可以通过wait4()系统调用查询子进程是否终结，这使得进程拥有了等待特定进程执行完毕的能力。

进程退出执行后被设置为僵死状态，直到它的父进程调用wait()或waitpid()为止。

内核把进程的列表存放在叫做任务队列的双向循环链表中。
链表的每一项都是类型为task_struct称为进程描述符的结构，进程描述符中包含一个具体进程的所有信息。

进程描述符中包含的数据能完整的描述一个正在执行的程序：打开的文件，进程的地址空间，挂起的信号，进程的状态等。

Linux通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色(cache coloring)。
